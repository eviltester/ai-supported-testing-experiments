<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Tank Arena</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: white;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #16213e;
            background: #0f3460;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
        }
        
        .controls {
            margin-top: 10px;
            text-align: center;
            opacity: 0.8;
        }
        
        .score {
            margin-bottom: 10px;
            font-size: 18px;
            color: #00ff41;
        }
    </style>
</head>
<body>
    <div class="score">Score: <span id="score">0</span> | Enemies: <span id="enemies">0</span></div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="controls">
        Use arrow keys to move and rotate | SPACE to shoot
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const enemiesElement = document.getElementById('enemies');

        // Game state
        let score = 0;
        let gameRunning = false; // Start with intro screen
        let gameState = 'intro'; // 'intro' or 'playing'
        let lastEnemySpawn = 0;
        let keys = {};
        
        // Enemy colors array
        const enemyColors = ['#ff4757', '#ff6348', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43', '#10ac84'];

        // Player tank
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            speed: 0,
            maxSpeed: 3,
            acceleration: 0.2,
            friction: 0.9,
            size: 20,
            color: '#00ff41'
        };

        // Game objects arrays
        const enemies = [];
        const bullets = [];
        const enemyBullets = [];
        const particles = [];

        // Particle class for explosions
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 1;
                this.decay = 0.02 + Math.random() * 0.02;
                this.size = 2 + Math.random() * 3;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
                this.size *= 0.99;
                
                return this.life <= 0;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.restore();
            }
        }

        // Create explosion particles
        function createExplosion(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }
        class Tank {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0;
                this.maxSpeed = 1.5;
                this.size = 18;
                this.color = enemyColors[Math.floor(Math.random() * enemyColors.length)];
                this.lastShot = 0;
                this.health = 1;
                this.targetAngle = 0;
                this.target = null; // Can target player or other tanks
            }

            findNearestTarget() {
                let nearestTarget = player;
                let nearestDistance = this.getDistanceTo(player);
                
                // Check all other enemies
                for (let enemy of enemies) {
                    if (enemy === this) continue;
                    
                    let distance = this.getDistanceTo(enemy);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestTarget = enemy;
                    }
                }
                
                this.target = nearestTarget;
                return nearestDistance;
            }
            
            getDistanceTo(target) {
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            update() {
                // Find nearest target (player or other enemy)
                const distance = this.findNearestTarget();
                
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                
                // Calculate angle to target
                this.targetAngle = Math.atan2(dy, dx);
                
                // Rotate toward target
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                this.angle += angleDiff * 0.02;
                
                // Move toward target if it's far, back away if too close
                if (distance > 120) {
                    this.speed = Math.min(this.speed + 0.1, this.maxSpeed);
                } else if (distance < 80) {
                    this.speed = Math.max(this.speed - 0.1, -this.maxSpeed * 0.5);
                } else {
                    this.speed *= 0.95;
                }
                
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Keep in bounds
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                
                // Shoot at target occasionally
                if (Date.now() - this.lastShot > 1500 + Math.random() * 2000 && distance < 250) {
                    this.shoot();
                    this.lastShot = Date.now();
                }
            }

            shoot() {
                enemyBullets.push(new Bullet(this.x, this.y, this.angle, '#ff6b7a', false, this));
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Tank body
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                
                // Tank barrel
                ctx.fillRect(this.size/2 - 2, -3, this.size/2, 6);
                
                // Tank direction indicator
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.size/3, -2, 8, 4);
                
                ctx.restore();
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, angle, color = '#ffff00', isPlayer = true, owner = null) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.angle = angle;
                this.speed = 4; // Half the original speed
                this.color = color;
                this.isPlayer = isPlayer;
                this.owner = owner; // Reference to the tank that fired this bullet
                this.size = 3;
                this.maxRange = canvas.width / 4; // Quarter of screen width
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Calculate distance traveled
                const dx = this.x - this.startX;
                const dy = this.y - this.startY;
                const distanceTraveled = Math.sqrt(dx * dx + dy * dy);
                
                // Remove if out of bounds or reached max range
                if (this.x < 0 || this.x > canvas.width || 
                    this.y < 0 || this.y > canvas.height || 
                    distanceTraveled >= this.maxRange) {
                    
                    // Create explosion when bullet expires
                    createExplosion(this.x, this.y, this.color, 8);
                    return true;
                }
                
                return false;
            }

            explode() {
                // Create explosion particles
                createExplosion(this.x, this.y, this.color, 12);
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
            }
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // Start game from intro screen
            if (gameState === 'intro' && e.code === 'Space') {
                gameState = 'playing';
                gameRunning = true;
                initGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Collision detection
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (obj1.size/2 + obj2.size/2);
        }

        // Spawn enemy
        function spawnEnemy() {
            let x, y;
            // Spawn at edges
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? 0 : canvas.width;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? 0 : canvas.height;
            }
            enemies.push(new Tank(x, y));
        }

        // Draw tank
        function drawTank(tank) {
            ctx.save();
            ctx.translate(tank.x, tank.y);
            ctx.rotate(tank.angle);
            
            // Tank body
            ctx.fillStyle = tank.color;
            ctx.fillRect(-tank.size/2, -tank.size/2, tank.size, tank.size);
            
            // Tank barrel
            ctx.fillRect(tank.size/2 - 2, -3, tank.size/2, 6);
            
            // Tank direction indicator
            ctx.fillStyle = '#fff';
            ctx.fillRect(tank.size/3, -2, 8, 4);
            
            ctx.restore();
        }

        // Draw intro screen
        function drawIntroScreen() {
            // Clear canvas with dark background
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Game title
            ctx.fillStyle = '#00ff41';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('ANGRY TANK ARENA', canvas.width / 2, 120);
            
            // Subtitle
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Courier New';
            ctx.fillText('Survive the multi-faction tank warfare!', canvas.width / 2, 160);
            
            // Game description
            ctx.fillStyle = '#cccccc';
            ctx.font = '16px Courier New';
            ctx.textAlign = 'left';
            
            const descY = 220;
            const lineHeight = 25;
            const descriptions = [
                'You are the GREEN tank in a hostile arena filled with enemy tanks.',
                'Enemy tanks will spawn regularly and fight both you and each other.',
                'Each tank has different colors and will target the nearest threat.',
                'Bullets have limited range and create explosive particle effects.',
                'Survive as long as possible and rack up the highest score!'
            ];
            
            descriptions.forEach((desc, index) => {
                ctx.fillText(desc, 50, descY + (index * lineHeight));
            });
            
            // Controls section
            ctx.fillStyle = '#00ff41';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('CONTROLS', canvas.width / 2, descY + 160);
            
            // Control keys
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Courier New';
            ctx.textAlign = 'left';
            
            const controlsY = descY + 200;
            const controls = [
                '↑ ARROW UP     - Move Forward',
                '↓ ARROW DOWN   - Move Backward', 
                '← ARROW LEFT   - Rotate Left (5°)',
                '→ ARROW RIGHT  - Rotate Right (5°)',
                'SPACEBAR       - Shoot Bullets'
            ];
            
            controls.forEach((control, index) => {
                ctx.fillText(control, 150, controlsY + (index * 30));
            });
            
            // Scoring info
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 18px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SCORING', canvas.width / 2, controlsY + 180);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Courier New';
            ctx.fillText('Destroy enemy tanks: +100 points each', canvas.width / 2, controlsY + 210);
            ctx.fillText('(No points for enemy vs enemy kills)', canvas.width / 2, controlsY + 235);
            
            // Start instruction
            ctx.fillStyle = '#ff6348';
            ctx.font = 'bold 24px Courier New';
            ctx.fillText('PRESS SPACE TO START!', canvas.width / 2, controlsY + 290);
            
            // Blinking effect for start text
            if (Math.floor(Date.now() / 500) % 2) {
                ctx.fillStyle = '#ff4757';
                ctx.fillText('PRESS SPACE TO START!', canvas.width / 2, controlsY + 290);
            }
            
            // Draw border
            ctx.strokeStyle = '#16213e';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
        }
        function gameLoop() {
            if (!gameRunning) return;

            // Clear canvas completely
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Handle input
            if (keys['ArrowUp']) {
                player.speed = Math.min(player.speed + player.acceleration, player.maxSpeed);
            } else if (keys['ArrowDown']) {
                player.speed = Math.max(player.speed - player.acceleration, -player.maxSpeed/2);
            }

            if (keys['ArrowLeft']) {
                player.angle -= 5 * Math.PI / 180; // 5 degrees in radians
            }
            if (keys['ArrowRight']) {
                player.angle += 5 * Math.PI / 180;
            }

            if (keys['Space']) {
                // Limit shooting rate
                if (!player.lastShot || Date.now() - player.lastShot > 200) {
                    bullets.push(new Bullet(player.x, player.y, player.angle, '#ffff00', true, player));
                    player.lastShot = Date.now();
                }
            }

            // Apply friction
            player.speed *= player.friction;

            // Update player position
            player.x += Math.cos(player.angle) * player.speed;
            player.y += Math.sin(player.angle) * player.speed;

            // Keep player in bounds
            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

            // Spawn enemies
            const now = Date.now();
            if (now - lastEnemySpawn > (10000 + Math.random() * 5000)) {
                spawnEnemy();
                lastEnemySpawn = now;
            }

            // Update enemies
            enemies.forEach(enemy => enemy.update());

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (bullets[i].update()) {
                    bullets.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (particles[i].update()) {
                    particles.splice(i, 1);
                }
            }
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (enemyBullets[i].update()) {
                    enemyBullets.splice(i, 1);
                }
            }

            // Check bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (checkCollision(bullets[i], enemies[j])) {
                        bullets[i].explode(); // Create explosion
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        score += 100;
                        break;
                    }
                }
            }

            // Check enemy bullet collisions (with player and other enemies, but not self)
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let bulletHit = false;
                
                // Check collision with player
                if (checkCollision(enemyBullets[i], player)) {
                    enemyBullets[i].explode(); // Create explosion
                    gameRunning = false;
                    alert(`Game Over! Final Score: ${score}`);
                    location.reload();
                    return;
                }
                
                // Check collision with other enemies (but not the one who fired it)
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (enemies[j] !== enemyBullets[i].owner && checkCollision(enemyBullets[i], enemies[j])) {
                        enemyBullets[i].explode(); // Create explosion
                        enemyBullets.splice(i, 1);
                        enemies.splice(j, 1);
                        // No points for enemy vs enemy kills
                        bulletHit = true;
                        break;
                    }
                }
            }

            // Check enemy-player collisions
            for (let enemy of enemies) {
                if (checkCollision(enemy, player)) {
                    gameRunning = false;
                    alert(`Game Over! Final Score: ${score}`);
                    location.reload();
                    return;
                }
            }

            // Draw everything
            drawTank(player);
            enemies.forEach(enemy => enemy.draw());
            bullets.forEach(bullet => bullet.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            particles.forEach(particle => particle.draw());

            // Draw arena border
            ctx.strokeStyle = '#16213e';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // Update UI
            scoreElement.textContent = score;
            enemiesElement.textContent = enemies.length;

            requestAnimationFrame(gameLoop);
        }

        // Start game
        function initGame() {
            // Reset game state
            score = 0;
            enemies.length = 0;
            bullets.length = 0;
            enemyBullets.length = 0;
            particles.length = 0;
            
            // Reset player position
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.angle = 0;
            player.speed = 0;
            
            // Spawn 4 initial enemy tanks at different positions
            spawnEnemy(); // Top edge
            spawnEnemy(); // Random edge
            spawnEnemy(); // Random edge 
            spawnEnemy(); // Random edge
            
            lastEnemySpawn = Date.now();
        }
        
        // Start the game loop
        gameLoop();
    </script>
</body>
</html>